<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bcc on 如创科技</title><link>https://www.rutron.net/tags/bcc/</link><description>Recent content in bcc on 如创科技</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 23 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.rutron.net/tags/bcc/index.xml" rel="self" type="application/rss+xml"/><item><title>[译]什么是 eBPF?</title><link>https://www.rutron.net/posts/2203/what-is-ebpf/</link><pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.rutron.net/posts/2203/what-is-ebpf/</guid><description>eBPF 程序是事件驱动的, 能在内核或应用程序执行到一个特定的 hook 点时执行. 预定义的 hooks 包含系统调用, 函数出/入口, 内核追踪点, 网络事件等等. 如果预定义 hook 不能满足需求, 也可以创建内核探针(kprobe)或者用户探针(uprobe), 在内核/用户应用程序的任何位置, 把探针附加到 eBPF 程序上.</description></item><item><title>bcc 之 opensnoop 工具的使用</title><link>https://www.rutron.net/posts/2203/bcc-opensnoop-usage/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.rutron.net/posts/2203/bcc-opensnoop-usage/</guid><description>这篇文档主要演示了 opensnoop(Linux eBPF/bcc) 工具的使用. opensnoop 在系统范围内跟踪 open() 系统调用，并打印各种详细信息.</description></item><item><title>bcc 之 tcplife 工具的使用</title><link>https://www.rutron.net/posts/2203/bcc-tcplife-usage/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.rutron.net/posts/2203/bcc-tcplife-usage/</guid><description>这篇文档主要演示了 tcplife(Linux eBPF/bcc) 工具的使用. tcplife 总结了在跟踪期间打开和关闭的 TCP 会话. 比如</description></item></channel></rss>